# GraphQL <span class="red">не нужен</span>, если

-----

- Работа с файлами или другими бинарными данными
  - GraphQL создавался для типизированных структур, бинарные данные он может передавать только в виде base64 строки. А это увеличивает более чем на 30% исходный размер файла. Тратим сеть, память, процессор. И можем передать файл не более 380MB (т.к. в NodeJS ограничение на строку в 500MB)
  - Альтернатива, это микс GraphQL и http-multipart <https://github.com/jaydenseric/graphql-multipart-request-spec>. Правда это уже "франкенштейн" из GraphQL и Multipart из REST API. Тут много что делает Server, который тюнит транспорт.
  - Используйте S3 signed-urls для загрузки бинарных данных через REST. GraphQL может передавать эти ссылки, но не сами бинарные данные. <https://github.com/nodkz/conf-talks/tree/master/articles/graphql/fileUploads>
  - Но никогда не говори никогда: мы вынуждены передавать base64 файлы при отправки писем со счетами на оплату. Сервис биллинга формирует уведомление, а вот сервис уведомлений уже делает отправку писем со вложениями.
- CRDT и многопользовательское редактирование с версионированием
  - Conflict-free Replicated Data Types
  - Это целая наука разбирать конфликты и синхронизировать состояние. Вы конечно можете GraphQL прикрутить со стороны, но боюсь что вы провалитесь в прекрасный мир типизации всего этого добра. Проще взять готовые решения, чем крутить свой велосипед.
  - Ну нет толком никаких алгоритмов в GraphQL <https://arxiv.org/pdf/1608.03960.pdf> take fig.9 as an example
- Аутентификация
  - Ох сколько копий мы поломали, пытаясь запихнуть ввод логина и пароля через GraphQL.
  - Операция `login` – это Query или Mutation?
  - Хорошо, а это законно в резолвере устанавливать куку пользователю? Ведь GraphQL вроде как протоколо-независим. (У нас есть GraphQL-метод loginAsClient, он устанавливает куку)
  - А еще сброс пароля по ссылке, двухфакторка, oidc (oauth2)
  - В любом случае большинство современных систем аутентификации построены поверх http c кучей редиректов. Работа с http, редиректами, куками – это не про GraphQL.
  - И зачем вам нужна типизация при вводе логина и пароля от GraphQL – не понятно. Проще сервис аутентификации пелить без GraphQL.
  - А вот к примеру просмотр и редактирование профиля клиента, уже вполне хорошо ложиться в GraphQL. Тут просто тупая работа с типизированными данными.
  - Немного про Индетификацию/Авторизацию
    - Проще сделать весь графкуэль защищенным на уровне формирования контекста, чем в каждом резолвере индетифицировать пользователя. Ведь где-то точно пропустите проверку, и данные получат неиндетифицированные пользователи. Ну авторизацию (проверку прав), вам все равно придется крутить в каждом резолвере. Но это дело могут облегчить миддлвары для резолверов.
    - Заводить два GraphQL, отдельно для неавторизированных пользователей, отдельно для авторизированных.
- Активное межсерверное взаимодействие требовательное к скорости, памяти и траффику
  - Protobuf отличное решение для межсерверного общения. Имея много разных типов их можно хорошо сжимать. А у JSON даже Int нормального нет и тупо гзипится(бротлится) строка с кучей повторов строковых ключей.
  - У вас в проде крутится сотни серверов? Тогда бизнесу становится выгоднее платить разработчику, чтоб он занимался сокращением байтов и тактов. И в gRPC/protobuf это неплохо уже отточено.
- Стримминг данных
  - Хоть в GraphQL есть Subscriptions, которыми удобно пользоваться через Apollo Client или Relay. То вот стримить например котировки для бирж, выглядит сомнительным решением – уж больно много накладных расходов как по сети, так и по CPU.
- Сложные формы с вариантивными инпутами (union типы)
  - Для какого-то аргумента вы хотите передать строку или сложный объект. Передать такой аргумент можно используя тип JSON, но у вас не будет статической типизации. 
  - Например в Контуре есть команда у которой 2000 сложных форм, и там используют DTO с кодогенерацией, и такой подход в разы удобнее и безопаснее. Правда можно накостылить стороннюю валидацию JSON типов в GraphQL, но с ней не будет взаимодействовать большинство существующего инструментария - кодогенерация, линтинг, автоподстановка полей в GraphiQL.
  - В GraphQL нет InputUnionType. [Спецификация](https://github.com/graphql/graphql-spec/blob/main/rfcs/InputUnion.md) по ним уже обсуждается года три. Когда она выйдет в свет, то скорее всего этот пункт станет неактуальным.