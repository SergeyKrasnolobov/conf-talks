# GraphQL <span class="red">не нужен</span>, если

-----

### GraphQL не нужен, если вам нужно <!-- .element: class="red" -->

- работать с файлами или другими бинарными данными <!-- .element: class="fragment" -->
- CRDT и многопользовательское редактирование с версионированием <!-- .element: class="fragment" -->
- создать сервис Аутентификации пользователей <!-- .element: class="fragment" -->
- активное межсерверное взаимодействие требовательное к скорости, памяти и траффику <!-- .element: class="fragment" -->
- стримминг данных <!-- .element: class="fragment" -->
- создавать сложные формы с вариантивными инпутами (input-union типы) <!-- .element: class="fragment" -->

-----

## Работа с файлами или другими бинарными данными <!-- .element: class="red" -->
  
- GraphQL создавался для типизированных структур, бинарные данные он может передавать только в виде base64 строки. А это увеличивает более чем на 30% исходный размер файла. Тратим сеть, память, процессор. И можем передать файл не более 380MB.
- Альтернатива, это микс GraphQL и http-multipart <https://github.com/jaydenseric/graphql-multipart-request-spec>. Правда это уже "франкенштейн" из GraphQL и Multipart из REST API. Тут много что делает Server, который тюнит транспорт.

-----

- Используйте S3 signed-urls для загрузки бинарных данных через REST. GraphQL может передавать эти ссылки, но не сами бинарные данные. <https://github.com/nodkz/conf-talks/tree/master/articles/graphql/fileUploads>
- Но никогда не говори никогда: мы вынуждены передавать base64 файлы при отправки писем со счетами на оплату. Сервис биллинга формирует уведомление, а вот сервис уведомлений уже делает отправку писем со вложениями.

-----

## CRDT и многопользовательское редактирование с версионированием <!-- .element: class="red" -->
  
- Conflict-free Replicated Data Types
- Это целая наука разбирать конфликты и синхронизировать состояние. Вы конечно можете GraphQL прикрутить со стороны, но боюсь что вы провалитесь в прекрасный мир типизации всего этого добра. Проще взять готовые решения, чем крутить свой велосипед.
- Ну нет толком никаких алгоритмов в GraphQL <https://arxiv.org/pdf/1608.03960.pdf> take fig.9 as an example

-----

## Аутентификация <!-- .element: class="red" -->
   
- Ох сколько копий мы поломали, пытаясь запихнуть ввод логина и пароля через GraphQL.
- Операция `login` – это Query или Mutation?
- Хорошо, а это законно в резолвере устанавливать куку пользователю? Ведь GraphQL вроде как протоколо-независим. (У нас есть GraphQL-метод loginAsClient, он устанавливает куку)
- А еще сброс пароля по ссылке, двухфакторка, oidc (oauth2)

-----

- В любом случае большинство современных систем аутентификации построены поверх http c кучей редиректов. Работа с http, редиректами, куками – это не про GraphQL.
- И зачем вам нужна типизация при вводе логина и пароля от GraphQL – не понятно. Проще сервис аутентификации пилить без GraphQL.
- А вот к примеру просмотр и редактирование профиля клиента, уже вполне хорошо ложиться в GraphQL. Тут просто тупая работа с типизированными данными.

-----

- Немного про Индетификацию/Авторизацию
  - Проще сделать весь графкуэль защищенным на уровне формирования контекста, чем в каждом резолвере индетифицировать пользователя. Ведь где-то точно пропустите проверку, и данные получат неиндетифицированные пользователи. 
  - Ну авторизацию (проверку прав), вам все равно придется крутить в каждом резолвере. Но это дело могут облегчить миддлвары для резолверов.
  - Рекомендую заводить два GraphQL, отдельно для неавторизированных пользователей, отдельно для авторизированных.

-----

## Активное межсерверное взаимодействие требовательное к скорости, памяти и траффику <!-- .element: class="red" -->
  
- Protobuf отличное решение для межсерверного общения. Имея много разных типов их можно хорошо сжимать. Тупо гзипить (бротлить) сериализованную строку менее эффективно.
- У вас в проде крутится сотни серверов? Тогда бизнесу становится выгоднее платить разработчику, чтоб он занимался сокращением байтов и тактов. И в gRPC/protobuf это уже неплохо отточено.

-----

## Стримминг данных <!-- .element: class="red" -->
  
- Хоть в GraphQL есть Subscriptions, которыми удобно пользоваться через Apollo Client или Relay.
- То вот стримить например котировки для бирж, выглядит сомнительным решением – уж больно много накладных расходов как по сети, так и по CPU.
- Стримить видео – это вообще не про GraphQL.

-----

## Сложные формы с вариантивными инпутами (union типы) <!-- .element: class="red" -->
  
- Для какого-то аргумента вы хотите передать строку или сложный объект. Передать такой аргумент можно используя тип JSON, но у вас не будет статической типизации. 
- В GraphQL нет InputUnionType. [Спецификация](https://github.com/graphql/graphql-spec/blob/main/rfcs/InputUnion.md) по ним уже обсуждается года три. Когда она выйдет в свет, то скорее всего этот пункт станет неактуальным.

-----

- Например в Контуре есть команда у которой 2000 сложных форм, и там используют DTO с кодогенерацией, и такой подход в разы удобнее и безопаснее. 
- Правда можно накостылить стороннюю валидацию JSON типов в GraphQL, но с ней не будет взаимодействовать большинство существующего инструментария – кодогенерация, линтинг, автоподстановка полей в GraphiQL.

