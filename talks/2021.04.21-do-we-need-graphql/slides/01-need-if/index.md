# GraphQL <span class="green">нужен</span>, если

-----

### GraphQL нужен, если <!-- .element: class="green" -->

- взаимодействие между бэком и фронтом <!-- .element: class="fragment" -->
- боль от мульёна микросервисов со своими эндпоинтами <!-- .element: class="fragment" -->
- нужны тонкие клиенты на фронтенде <!-- .element: class="fragment" -->
- нужна статическая типизация <!-- .element: class="fragment" -->
- вам тесно в парадигме 4 операций CRUD в RESTfull API (изменения состояния) <!-- .element: class="fragment" -->
- много разных entity (models), между ними много связей и клиенты хотят сами собирать агрегации (а-ля LEFT JOIN) <!-- .element: class="fragment" -->
- у вас большие Entity как у GitHub, и слишком затратно таскать все 100 полей, когда нужно всего два поля <!-- .element: class="fragment" -->

-----

## Взаимодействие между бэком и фронтом <!-- .element: class="green" -->

- GraphQL разрабатывался для удобства фронтендеров
- в SPA и мобилках желательно использовать "умные стейт-менеджеры", типа Apollo Client, Relay и пр., которые дико упрощают выполнение запросов, кешируют и нормализовывают данные

-----

## Мульён микросервисов со своими эндпоинтами <!-- .element: class="green" -->

- Когда список ендпоинтов начинает идти на сотни, то знание о них и связями между ними можно заложить в GraphQL.
- Зачем мучить бедных фронтендеров безумным пластом знаний, учить их тому как устроена наша бэкендерская кухня, которая постоянно меняется. И документация постоянно устаревает.

-----

## Нужны тонкие клиенты на фронтенде согласно серверной схеме данных <!-- .element: class="green" -->
  
- graphql-codegen может прекрасно генерировать фетчеры данных на базе GraphQL-запросов (не путать с GraphQL-схемой.
- Т.е. если для OpenAPI, json-rpc генерируются полные клиенты со всеми методами, типами и полями.
- То с GraphQL можно генерировать только то, что есть в GraphQL-запросах, пропуская тысячи реально неиспользуемых типов и полей).

-----

## Нужна статическая типизация <!-- .element: class="green" -->
  
- к примеру graphql-codegen генерирует typescript дефинишены согласно GraphQL-запросов, и если поменяется тип у поля на бэке, либо оно удалиться, то любое неправильное употребление полей можно будет отловить на билде приложения

-----

## Если вам тесно в парадигме 4 операций CRUD в RESTfull API <!-- .element: class="green" -->
  
- например операции "провести оплату", "приостановить подписку" и пр. достаточно плохо ложатся в CRUD (изменение состояния).
- тут нужно смотреть в сторону RPC.
- GraphQL лучше json-rpc в следующих вещах:
  - вызвать получение вложенных данных на результате выполнения родительской операции;
  - удобные IDE для написания запросов и их проверки;
  - побогаче туллинг кодогенерации.

-----

### Много разных entity (models), между ними много связей и клиенты хотят сами собирать агрегации (а-ля LEFT JOIN). <!-- .element: class="green" -->
  
- часто удобно для всяких админок и дашбордов на клиентских приложениях
- написать самостоятельно сложную выборку данных из чужого сервиса достаточно просто
- когда много разработчиков, нужен какой-то инструмент для хранения знаний о DataDomain, удобный язык общения, стабильная спецификация.
- и даже на бэкенде сервисы могут общаются через GraphQL, если нужны сложные управляемые выборки

-----

## У вас большие Entity как у GitHub, и таскать все 100 полей, когда нужно всего два поля слишком затратно <!-- .element: class="green" -->
  
- graphql-codegen позволяет генерировать удобные fetche'ы (react hooks), которые содержать в себе только используемы поля.
- Если схема на 10000 типов, то в рантайм и сборку попадут только используемые типы и поля (в отличие от OpenApi, json-rpc где генераторы клиентов создают клиента с полным описанием всех методов, типов и полей.)
