# GraphQL <span class="green">нужен</span>, если

-----

- взаимодействие между бэком и фронтом
  - GraphQL разрабатывался для удобства фронтендеров
  - в SPA и мобилках желательно использовать "умные стейт-менеджеры", типа Apollo Client, Relay и пр., которые дико упрощают выполнение запросов, кешируют и нормализовывают данные
- мульён микросервисов со своими ендпоинтами
  - когда список ендпоинтов начинает идти на сотни, то знание о них и связями между ними можно заложить GraphQL. Зачем мучить бедных фронтендеров безумным пластом знаний, учить их тому как устроена наша бэкендерская кухня, которая и без того постоянно меняется.
- нужны тонкие клиенты на фронтенде согласно серверной схеме данных
  - graphql-codegen может прекрасно генерировать фетчеры данных на базе GraphQL-запросов (не путать с GraphQL-схемой. Т.е. если для OpenAPI, json-rpc генерируются полные клиенты со всеми методами, типами и полями. То с GraphQL можно генерировать только то, что есть в GraphQL-запросах, пропуская тысячи реально неиспользуемых типов и полей).
- нужна статическая типизация
  - к примеру graphql-codegen генерирует typescript дефинишены согласно GraphQL-запросов, и если поменяется тип у поля на бэке, либо оно удалиться, то любое неправильное потребление полей можно будет отловить на билде приложения
- если вам тесно в парадигме 4 операций CRUD в RESTfull API (изменения состояния)
  - например операции "провести оплату", "приостановить подписку" и пр. достаточно плохо ложатся в CRUD
  - тут нужно смотреть в сторону RPC (отправляя на пенсию HTTP-методы). При этом если вы смотрите в сторону json-rpc, то лучше рассмотрите GraphQL. Они практически идентичны, только у GraphQL, есть возможно вызвать получение вложенных данных на результате выполнения родительской операции; удобная браузерная IDE для написания запросов и их проверке; побогаче туллинг кодогенерации.
- если много разных entity (models), между ними много связей и клиенту нужны их агрегации (а-ля LEFT JOIN) и желательно за один http-запрос.
  - часто удобно для всяких админок и дашбордов на клиентских приложениях
  - но даже некоторые бэкенды (сервисы) общаются через GraphQL, так как очень много связей между Entity и GraphQL неплохо передает эти знания через свою схему, и написать самостоятельно сложную выборку данных из чужого сервиса достаточно просто
  - когда много разработчиков, нужен какой-то инструмент для хранения знаний о DataDomain и язык общения. У GraphQL ytgkj
- у вас большие Entity как у GitHub, и таскать все 100 полей, когда нужно всего два поля слишком затратно
  - также graphql-codegen позволяет генерировать удобные fetche'ы (react hooks), которые содержать в себе только используемы поля. Если схема на 10000 типов, то в рантайм и сборку попадут только используемые типы и поля (в отличие от OpenApi, json-rpc где генераторы клиентов создают клиента с полным описанием всех методов, типов и полей.)