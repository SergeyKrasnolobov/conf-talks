# Тезисы:

## Нужен если:

- взаимодействие между бэком и фронтом, у которого предполагается стейт менеджером (SPA, мобилки)
- нужна статическая типизация на фронте согласно серверной схеме данных
- если много разных entity (models), между ними много связей и клиенту нужны их агрегации (а-ля LEFT JOIN) и желательно за один http-запрос.

## Не нужен, если:

- Работа с файлами или другими бинарными данными
  - GraphQL создавался для типизированных структур, бинарные данные он может передавать только в виде base64 строки. А это увеличивает более чем на 30% исходный размер файла. Тратим сеть, память, процессор. И можем передать файл не более 380MB (т.к. в NodeJS ограничение на строку в 500MB)
  - Альтернатива, микс GraphQL и http-multipart <https://github.com/jaydenseric/graphql-multipart-request-spec>. Правда это уже не чистый графкуэль. Тут много что делает Server, который тюнит транспорт.
  - Используйте S3 signed-urls для загрузки бинарных данных через REST. GraphQL может передавать эти ссылки, но не сами бинарные данные. <https://github.com/nodkz/conf-talks/tree/master/articles/graphql/fileUploads>
  - Но никогда не говори никогда: мы вынуждены передавать base64 файлы при отправки писем со счетами на оплату. Сервис биллинга формирует уведомление, а вот сервис уведомлений уже делает рассылку.
- CRDT и многопользовательское редактирование с версионированием
  - Conflict-free Replicated Data Types
  - Это целая наука разбирать конфликты и синхронизировать состояние. Вы конечно можете GraphQL прикрутить со стороны, но боюсь что вы провалитесь в прекрасный мир типизации всего этого добра. Проще взять готовые решения, чем крутить свой велосипед.
  - Ну нет толком никаких алгоритмов в GraphQL <https://arxiv.org/pdf/1608.03960.pdf> take fig.9 as an example
- Аутентификация, если есть oidc (oauth2)
  - Ох сколько копий мы поломали, пытаясь запихнуть ввод логина и пароля через GraphQL.
  - Операция `login` – это Query или Mutation?
  - Хорошо, а это законно в резолвере устанавливать куку пользователю? Ведь GraphQL вроде как протоколо-независим.
  - Проще сделать весь графкуэль защищенным, чем в каждом резолвере проверять пользователя. Ведь где-то точно пропустите проверку, и данные получат неаутентифицированные пользователи.
  - Заводить два GraphQL, отдельно для неавторизированных пользователей, отдельно для авторизированных.
- Активное межсерверное взаимодействие требовательное к скорости, памяти и траффику
  - Protobuf отличное решение для межсерверного общения. Имея много разных типов их можно хорошо сжимать. А у JSON даже Int нормального нет и тупо гзипится(бротлится) строка с кучей повторов строковых ключей.
  

## А что делать если мы попадаем в обе категории?

- Пилите два, три апи на разных технологиях. "Надо дать так, чтоб клиентам было удобно взять". Любое апи это фасад (контроллеры) перед сервисами и моделями. И напилякать их не так уж трудозатратно, если бизнес логика у вас вынесена на свой слой абстракции и разные имплементации апи переиспользуют её.

## Code first или Schema First?

- Schema First – это когда вы пишите схему (обычно в SDL формате), а потом натягиваете на нее резолверы
  - Быстрый старт
  - Для маленьких и средних приложений
  - На длинной дистанции, могут быть проблемы с рефакторингом и внесением изменений
- Code first – это когда у вас есть модели и сервисы, и уже из них генерируется либо пишутся с нуля GraphQL-типы и схема
  - Больше трудозатрат на написание своего генератора, либо поиск готового решения
    - Пример: не надо руками писать все Input-типы, если они по структуре одинаковы с Output-типами (не тратим время на синхронизацию)
    - Пример: graphql-compose-mongoose на одной модели генерирует более 60 GraphQL-типов.
  - На длинной дистанции, вы можете схему менять логику генератора и ваша схема будет меняться вне зависимости от размера схемы и кол-ва типов
- Если у вас гексагональная (или луковая) архитектура, есть DTO, куча интерфейсов, портов и адаптеров, увлекаетесь рефлексией и декораторами, то однозначно надо брать Code first. Зачем писать GraphQL-схему ручками через Schema First, когда вам достаточно артефактов, чтобы ее сгенерировать.

## Итого

Помним что GraphQL это инструмент, а не серебряная пуля. И каждый инструмент удобен под свою категорию задач. Молотком шуруп не закрутишь, отверткой гвоздь не забьешь - это практически нереально, хотя я полагаю, умельцы найдутся.
